---
title: "02: Packages and functions"
author: "Brenna Kelly"
format:
  html:
    toc: true
    toc-location: left
editor: source
editor_options: 
  chunk_output_type: console
---

## Base R

We've seen some of the capabilities of what's called `base` R. It's very extensible and can be used for many of the tasks we'll cover in this workshop. However, we'll now learn from a few **packages** developed to make our lives easier. Because R is open source, anyone can contribute to it — folks can write functions, create a unifying package, and share with anyone. (Those that meet certain standards are included in CRAN — the Comprehensive R Archive Network.)

Base R is ready to use as soon as you open a session in R studio. To work with packages (and the handy functions they contain), we need to take a couple extra steps.

## Getting started with a package

The first step is to install a package. This can be done using the GUI or with a line or two or code. Let's first install `dplyr`.

```{r}

# install.packages("dplyr")

```

You only need to install it once (but be sure to update regularly). Once installed, you can load the package with the function `library()`.

```{r}

library(dplyr)

```

Now you're ready to work with the package. To learn more about its functions, you can use `?package_name`. Some packages have better documentation than others, but tidyverse's is considered excellent (this include `dplyr`; more on that later). If you have installed a package but haven't loaded it with `library()` yet, you can use `??package_name` or `??function`.

::: callout-tip
Hours of trial and error can save you minutes of reading documentation.
:::

## Functions

In math, a function is a rule which assigns each input from a domain to exactly one output in a codomain. It's similar in programming. We provide input data to a function and expect an output, sometimes with a bit more information along with it. A function will also take arguments, or parameters which change the function's behavior. Let's play around with base R's `sample()` function with three colors, stored in a vector `x`.    

Create a vector `c()` of two coin toss results: `"H"` and `"T"`.  

```{r}

x <- c("H", "T")

```

Check the sample documentation. First, try with just x vector and no additional arguments.

```{r}

sample(x)

```

Now set the size argument to 8.  

```{r}

# sample(x, size = 8)

```

You should get an error. Try sampling again with replacement.

```{r}

sample(x, size = 8, replace = TRUE)

```

We can confirm in the documentation that the function is using uniform sampling - each value has equal probability assigned to it. We can adjust this with `prob` argument, which takes a vector of weights.

```{r}

sample(x, size = 6, replace = TRUE, prob = c(0.9, 0.1))

```

Increase size to 100 and put the `sample` function inside the `table` function.

```{r}

table(
  sample(x, size = 100, replace = TRUE, prob = c(0.9, 0.1))
)

```

Using `size = 100` makes it easy to see the proportions of `"H"` and `"T"`. But if we used another number, say `size = 111`, it would be harder to estimate. If we put `table()` inside of the `prop.table()` function, we'll get the proportions directly:  

```{r}

prop.table(
  table(
    sample(x, size = 111, replace = TRUE, prob = c(0.9, 0.1))
  )
)

```

## Pipes
 
 Earlier we compared programming functions to mathematical functions. In math, a function has the form:    
 $y = f(x)$  
   
 In programming, we replace $f$ with our function, for instance:  
   
 `y <- sample(x)`  
   
 **Pipes** offer a variation in this syntax which is increasingly common:  
 
 `y <- x |> sample()`  
 or  
 `y <- x %>% sample()`  
 
Both `|>` and `%>%` are pipes. `|>` is the base R implementation, and `%>%` is the tidyverse predecessor, which is useful for more advanced operations. For the simple cases used in this workshop, we can consider them to be equivalent.  
 
Pipe notation is thought to be more readable. Normal code is read "inside-out" with respect to orders of operations:  

```{r}
# e.g.,

log(
  sqrt(
    5 * 2^3
  )
)

# i.e., 

log(sqrt(5 * 2^3))

```

whereas pipe notation code is read "left-to-right":  

```{r}

(5 * 2^3) |>
  sqrt() |>
  log()

```

Pipes pass the value of an expression forward to the next express, until the final value is returned. We can try this with the iris names. Here is the base syntax to convert the names to lowercase:  

```{r}

tolower(
  names(iris)
)

# equivalent to
tolower(names(iris))

```

Try converting the names to lowercase with pipes:  

```{r}

```


 

## Practice with functions

Read in the iris dataset again (practice `read.csv()`), then experiment with the following mathematical functions, which you'll likely use often:

-   `mean()`: the average

-   `median()`: the median

-   `min()`: the minimum value

-   `max()`: the maximum value

-   `quantile()`: quantiles corresponding to given probabilities

    -   i.e., `quantile(, probs = 0.5)` for 50th percentile)

-   `var()`: variance

-   `sd()`: standard deviation

-   `range()`: range

-   interquartile range, i.e., `quantile(, probs = c(0.25, 0.75))`

```{r}

iris <- read.csv("data/iris.csv")

```

1. Find which row has the maximum 
<find the row which has the maximum petal width>
- `which()`
- `which.max()`

```{r}

iris[which(iris$Petal.Width == max(iris$Petal.Width)), ]

iris[which.max(iris$Petal.Width), ] # more concise, only returns first

```

All three flowers with the maximum petal width are virginica species. This may be due to chance, but let's see if this is a systematically pattern. What is the average metal width by species?
There's a handy function in Base R for that: `aggregate()`.  

```{r}

aggregate(iris$Petal.Width, by = list(iris$Species), FUN = mean)

```






 
 